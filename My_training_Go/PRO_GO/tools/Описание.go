package main // Декларация пакета

import "fmt" // Оператор импорта

func main() {
	fmt.Println("Hello, Go") // Функция
}

/* package - ключевое слово; main - имя пакета

import - ключевое слово; "fmt" - имя пакета

func - ключевое слово; main - имя; () - параметры { Блок
	fmt.Println("Hello, Go")                      кода
}

fmt.Println("Hello, Go") Здесь fmt - ссылка на паке; . - Точка; Println - Название функци; ("Hello, Go") - арументы функции

*/

/* TODO Отладка кода Go
   установить пакет Delve go install github.com/go-delve/delve/cmd/dlv@latest
   dlv version
TODO Подготовка к отладке
TODO Использование отладчика стр.74
dlv debug main.go
Первым шагом является
создание точки останова, что делается путем указания местоположения
в коде
TODO break bp1 main.main:3
Команда break создает точку останова.
br1 - Имя
main - Пакет
. - Точка
main - Функция
: - Двоеточие
3 - Строка
Далее я собираюсь создать условие для точки останова, чтобы
выполнение было остановлено только тогда, когда указанное
выражение оценивается как true
condition bp1 i == 2
continue
Запустите команду, показанную в листинге 3-16, чтобы отобразить
текущее значение переменной с именем i.
print i

TODO Линтинг Go-кода

Я предпочитаю
использовать revive пакет линтера, который является прямой заменой
golint, но с поддержкой контроля применяемых правил.

go install github.com/mgechev/revive@latest

Формат TOML предназначен специально для файлов конфигурации
и описан на странице https://toml.io/en. Полный набор
параметров настройки восстановления описан на странице
https://github.com/mgechev/revive#configuration.

revive -config revive.toml // Вывода не будет т.к. правило отключено в revive.tolm

TODO Исправление распространенных проблем в коде Go

Команда go vet идентифицирует операторы, которые могут быть ошибочными.

TODO Форматирование кода Go str.89

go fmt main.go

TODO Использование стандартной библиотеки Go

Синтаксис короткого объявления переменных можно использовать только внутри функций,

Однако переопределение переменной разрешено, если используется короткий синтаксис, если
хотя бы одна из других определяемых переменных еще не существует и тип переменной не изменяется.

TODO Указатели

Тип указателя основан на типе переменной, из которой он создан, с
префиксом звездочки (символ *). Тип переменной с именем second —
*int, потому что она была создана путем применения оператора
адреса к переменной first, значение которой равно int. Когда вы
видите тип *int, вы знаете, что это переменная, значением которой
является адрес памяти, в котором хранится переменная типа int.
Тип указателя фиксирован, потому что все типы Go фиксированы, а
это означает, что когда вы создаете указатель, например, на int, вы
меняете значение, на которое он указывает, но вы не можете
использовать его для указания на адрес памяти, используемый для
хранения другого типа, например, float64. Это ограничение важно,
поскольку в Go указатели — это не просто адреса памяти, а, скорее,
адреса памяти, которые могут хранить определенный тип значения.

TODO 5. Операции и преобразования str/128
 +, -, *, /, % - Эти операторы используются для выполнения арифметических операций с
 числовыми значениями, как описано в разделе «Знакомство с арифметическими
 операторами». Оператор + также можно использовать для объединения строк, как
 описано в разделе «Объединение строк».
TODO
 ==, !=, <, <=, >, >= - Эти операторы сравнивают два значения, как описано в разделе
 «Общие сведения об операторах сравнения»
 == Этот оператор возвращает true, если операнды равны. И используется для сравнения ячеек памяти
 != Этот оператор возвращает true, если операнды не равны.
 < Этот оператор возвращает значение true, если первый операнд меньше второго операнда.
 > Этот оператор возвращает значение true, если первый операнд больше второго операнда.
 <= Этот оператор возвращает значение true, если первый операнд меньше или nравен второму операнду.
 >= Этот оператор возвращает значение true, если первый операнд больше или равен
 второму операнду.
Значения, используемые с операторами сравнения, должны быть
одного типа или должны быть нетипизированными константами,
которые могут быть представлены как целевой тип,
TODO
 ||, &&, ! - Это логические операторы, которые применяются к bool значениям и
 возвращают bool значение, как описано в разделе «Понимание логических
 операторов»
 || Этот оператор возвращает true (истину), если любой из операндов true. Если
 первый операнд true, то второй операнд не будет оцениваться. (ИЛИ)
 && Этот оператор возвращает true, если оба операнда true. Если первый операнд
 false, то второй операнд не будет оцениваться. (И)
 ! Этот оператор используется с одним операндом. Он возвращает true, если
 операнд false, и false, если операнд true.
TODO
 =, := - Это операторы присваивания. Стандартный оператор присваивания (=)
 используется для установки начального значения при определении константы
 или переменной или для изменения значения, присвоенного ранее определенной
 переменной. Сокращенный оператор (:=) используется для определения
 переменной и присвоения значения, как описано в главе 4.
TODO
 -=, +=, ++, -- - Эти операторы увеличивают и уменьшают числовые значения, как описано в
 разделе «Использование операторов увеличения и уменьшения».
 Операторы ++ и -- увеличивают или уменьшают значение на единицу.
 += и -= увеличивают или уменьшают значение на указанную величину.
TODO
 &, |, ^, &^, <<, >> - Это побитовые операторы, которые можно применять к целочисленным
 значениям. Эти операторы не часто требуются в основной разработке, но вы
 можете увидеть пример в главе 31, где оператор | используется для настройки
 функций ведения журнала Go.

TODO Понимание операторов Go
 + Этот оператор возвращает сумму двух операндов.
 - Этот оператор возвращает разницу между двумя операндами.
 * Этот оператор возвращает произведение двух операндов.
 / Этот оператор возвращает частное двух операторов.
 % Этот оператор возвращает остаток от деления, который аналогичен оператору по
 модулю, предоставляемому другими языками программирования, но может
 возвращать отрицательные значения, как описано в разделе «Использование
 оператора остатка».

TODO Сравнение указателей
 Оператор равенства Go (==) используется для сравнения ячеек памяти.

TODO Преобразование, анализ и форматирование значений.
 Выполнение явных преобразований типов:
 Синтаксис для явных преобразований — T(x), где T — это целевой
 тип, а x — это значение или выражение для преобразования.
 Понимание ограничений явных преобразований.
Явные преобразования можно использовать только в том случае, если
значение может быть представлено в целевом типе. Это означает, что
вы можете выполнять преобразование между числовыми типами и
между строками и рунами, но другие комбинации, такие как
преобразование значений int в значения bool, не поддерживаются.
Следует соблюдать осторожность при выборе значений для
преобразования, поскольку явные преобразования могут привести к
потере точности числовых значений или вызвать переполнение
TODO Преобразование значений с плавающей запятой в целые числа.
Как показано в предыдущем примере, явные преобразования могут
привести к неожиданным результатам, особенно при преобразовании
значений с плавающей запятой в целые числа. Самый безопасный
подход — преобразовать в другом направлении, представляя целые
числа и значения с плавающей запятой, но если это невозможно, то
math пакет предоставляет набор полезных функций, которые можно
использовать для выполнения преобразований контролируемым образом.
TODO Функции в пакете math для преобразования числовых типов:
 Ceil(value) - Эта функция возвращает наименьшее целое число, большее
 указанного значения с плавающей запятой. Например, наименьшее
 целое число, большее 27.1, равно 28.
 Floor(value) - Эта функция возвращает наибольшее целое число, которое меньше
 указанного значения с плавающей запятой. Например, наибольшее
 целое число, меньшее 27.1, равно 28. В книге опечатка 27!!!
 Round(value) - Эта функция округляет указанное значение с плавающей запятой до
 ближайшего целого числа.
 RoundToEven(value - Эта функция округляет указанное значение с плавающей запятой до
 ближайшего четного целого числа.
Функции, описанные в выше, возвращают значения float64,
которые затем могут быть явно преобразованы в тип int,
TODO Парсинг из строк (str.146)
 Функции для преобразования строк в другие типы данных (пакет strconv)
 ParseBool(str) - Эта функция преобразует строку в логическое значение. Распознаваемые
 строковые значения: "true", "false", "TRUE", "FALSE", "True", "False",
 "T", "F", "0" и "1".
Если результат ошибки равен нулю, то строка успешно проанализирована. Если результат ошибки не nil, то
синтаксический анализ завершился неудачно.
TODO ParseFloat(str,size) - Эта функция анализирует строку в значение с плавающей запятой
 указанного размера, как описано в разделе «Анализ чисел с плавающей
 запятой».
 ParseInt(str, base, size) - Эта функция анализирует строку в int64 с указанным основанием и
 размером. Допустимые базовые значения: 2 для двоичного, 8 для
 восьмеричного, 16 для шестнадцатеричного и 10, как описано в разделе
 «Синтаксический анализ целых чисел».
 ParseUint(str, base, size) - Эта функция преобразует строку в целое число без знака с указанным
 основанием и размером.
 Atoi(str) - Эта функция преобразует строку в целое число с основанием 10 и
 эквивалентна вызову функции ParseInt(str, 10, 0), как описано в
 разделе «Использование удобной целочисленной функции».
 Функция Atoi принимает только значение для анализа и не
 поддерживает анализ недесятичных значений. Тип результата — int
 вместо int64, создаваемого функцией ParseInt.
TODO Разбор целых чисел.
Функции ParseInt и ParseUint требуют основания числа,
представленного строкой, и размера типа данных, который будет
использоваться для представления проанализированного значения.

TODO Разбор двоичных, восьмеричных и шестнадцатеричных целых чисел.(str.153).
 Аргумент base, полученный функциями Parse<Type>, позволяет анализировать недесятичные числовые строки,
 0b Этот префикс обозначает двоичное значение, например 0b1100100.
 0o Этот префикс обозначает восьмеричное значение, например 0o144.
 0x Этот префикс обозначает шестнадцатеричное значение, например 0x64.
 Использование удобной целочисленной функции.
 Разбор чисел с плавающей запятой.
Первым аргументом функции ParseFloat является анализируемое
значение. Второй аргумент определяет размер результата. Результатом
функции ParseFloat является значение float64, но если указано 32,
то результат можно явно преобразовать в значение float32.
Функция ParseFloat может анализировать значения, выраженные
с помощью экспоненты,
TODO Форматирование значений как строк.
 FormatBool(val) Эта функция возвращает строку true или false в зависимости от значения указанного bool значения.
 FormatInt(val, base) Эта функция возвращает строковое представление указанного значения int64,
 выраженное в указанной системе счисления.
 FormatUint(val, base) Эта функция возвращает строковое представление указанного значения uint64,
 выраженное в указанной базе.
 FormatFloat(val, format, precision, size) Эта функция возвращает строковое представление указанного значения float64,
 выраженное с использованием указанного формата, точности и размера.
 Itoa(val) Эта функция возвращает строковое представление указанного значения int, выраженное с использованием базы 10.

 TODO Форматирование значений с плавающей запятойю
Для выражения значений с плавающей запятой в виде строк требуются
дополнительные параметры конфигурации, поскольку доступны
разные форматы.
Fstring := strconv.FormatFloat(val, 'f', 2, 64)
Estring := strconv.FormatFloat(val, 'e', -1, 64)
Первым аргументом функции FormatFloat является
обрабатываемое значение. Второй аргумент — это byte значение,
указывающее формат строки. Байт обычно выражается как
литеральное значение руны, и в таблице ниже описаны наиболее часто
используемые форматы руны. (Как отмечалось в главе 4, тип byte
является псевдонимом для uint8 и часто для удобства выражается с
помощью руны.)
f - Значение с плавающей запятой будет выражено в форме ±ddd.ddd без
экспоненты, например 49.95.
e, E - Значение с плавающей запятой будет выражено в форме ±ddd.ddde±dd, например,
4.995e+01 или 4.995E+01. Регистр буквы, обозначающей показатель степени,
определяется регистром руны, используемой в качестве аргумента
форматирования.
Функция Описание
g, G - Значение с плавающей запятой будет выражено в формате e/E для больших
показателей степени или в формате f для меньших значений.

Третий аргумент функции FormatFloat указывает количество
цифр, которые будут следовать за десятичной точкой. Специальное
значение -1 можно использовать для выбора наименьшего количества
цифр, которое создаст строку, которую можно будет разобрать обратно
в то же значение с плавающей запятой без потери точности.
Последний аргумент определяет, округляется ли значение с
плавающей запятой, чтобы его можно было выразить как значение
float32 или float64, используя значение 32 или 64.
Эти аргументы означают, что этот оператор форматирует значение,
назначенное переменной с именем val, используя параметр формата f,
с двумя десятичными знаками и округляет так, чтобы значение могло
быть представлено с использованием типа float64:
...
Fstring := strconv.FormatFloat(val, 'f', 2, 64)
...
Эффект заключается в форматировании значения в строку, которую
можно использовать для представления денежной суммы.

TODO 6. Управление потоком выполнения. (str.163)

TODO Использование операторов if.
Ключевое слово else можно использовать для создания дополнительных предложений в операторе if.
Когда ключевое слово else сочетается с ключевым словом if, операторы кода в фигурных скобках выполняются только тогда,
когда выражение true, а выражение в предыдущем предложении false.
Комбинация else/if может быть повторена для создания последовательности предложений, каждое из которых будет выполняться
только тогда, когда все предыдущие выражения были false.
Ключевое слово else можно также использовать для создания резервного предложения, операторы которого будут выполняться
только в том случае, если все выражения if и else/if в операторе дадут ложные результаты.

TODO Понимание области действия оператора if.(str.171)
Каждое предложение в операторе if имеет свою собственную область
видимости, что означает, что доступ к переменным возможен только в
пределах предложения, в котором они определены. Это также означает,
что вы можете использовать одно и то же имя переменной для разных
целей в отдельных предложениях.
TODO Использование оператора инициализации с оператором if.
Go позволяет оператору if использовать оператор инициализации,
который выполняется перед вычислением выражения оператора if.
Оператор инициализации ограничен простым оператором Go, что
означает, в общих чертах, что оператор может определять новую
переменную, присваивать новое значение существующей переменной
или вызывать функцию.
Чаще всего эта функция используется для инициализации
переменной, которая впоследствии используется в выражении.

TODO Использование циклов for.
Ключевое слово for используется для создания циклов, которые
многократно выполняют операторы. Самые простые циклы for будут
повторяться бесконечно, если их не прервет ключевое слово break,
Ключевое слово return также может использоваться для завершения цикла.)
TODO Использование операторов инициализации и завершения.(str.177)
Циклы могут быть определены с помощью дополнительных
операторов, которые выполняются перед первой итерацией цикла
(известные как оператор инициализации) и после каждой итерации
(пост оператор).
Подсказка
Как и в случае с оператором if, круглые скобки могут быть
применены к условию оператора for, но не к операторам
инициализации или пост-операторам.
TODO Продолжение цикла.
Ключевое слово continue можно использовать для прекращения
выполнения операторов цикла for для текущего значения и перехода к
следующей итерации.
TODO Перечисление последовательностей.
Ключевое слово for можно использовать с ключевым словом range для
создания циклов, перебирающих последовательности.
TODO Получение только индексов или значений при перечислении последовательностей.
Go сообщит об ошибке, если переменная определена, но не используется.
Вы можете опустить переменную value в операторе for...range, если вам нужны только значения индекса.
Пустой идентификатор можно использовать, когда вам нужны только значения в последовательности, а не индексы
Пустой идентификатор (символ _) используется для индексной переменной, а обычная переменная используется для значений.

TODO Использование операторов switch.(str.184)
Оператор switch предоставляет альтернативный способ управления
потоком выполнения, основанный на сопоставлении результата
выражения с определенным значением, в отличие от оценки истинного
или ложного результата.

TODO Использование операторов switch
Оператор switch предоставляет альтернативный способ управления потоком выполнения, основанный на сопоставлении
результата выражения с определенным значением, в отличие от оценки истинного или ложного результата то может быть
краткий способ выполнения множественных сравнений,предоставляющий менее многословную альтернативу сложному
оператору if/elseif/else.
Примечание
Оператор switch можно также использовать для различения типов
данных, как описано в главе 11.
За ключевым словом switch следует значение или выражение, которое дает результат, используемый для сравнения. Сравнения
выполняются с серией операторов case, каждый из которых определяет значение.
 Сопоставление нескольких значений
В некоторых языках операторы switch «проваливаются», что означает, что после того, как оператор case установил
совпадение, операторы выполняются до тех пор, пока не будет достигнут оператор break, даже если это означает выполнение
операторов из последующего оператора case. Провал часто используется для того, чтобы позволить нескольким операторам
case выполнять один и тот же код, но он требует тщательного использования ключевого слова break, чтобы предотвратить
неожиданное выполнение выполнения.
 Операторы Go switch не выполняются автоматически, но можно указать несколько значений в списке, разделенном запятыми.
 Прекращение выполнения оператора case
Хотя ключевое слово break не требуется для завершения каждого оператора case, его можно использовать для завершения
выполнения операторов до того, как будет достигнут конец оператора case.
 Принудительный переход к следующему оператору case
Операторы Go switch не проваливаются автоматически, но это поведение можно включить с помощью ключевого слова fallthrough
 Предоставление пункта по умолчанию
Ключевое слово default используется для определения предложения, которое будет выполняться, когда ни один из операторов
case не соответствует значению оператора switch.
 Исключение значения сравнения
Go предлагает другой подход к операторам switch, который опускает значение сравнения и использует выражения в операторах
case. Этоподтверждает идею о том, что операторы switch являются краткой альтернативой операторам if.
 Использование операторов меток
Операторы меток позволяют выполнять переход к другой точке, обеспечивая большую гибкость, чем другие функции управления
потоком. Метки определяются именем, за которым следует двоеточие, а затем обычный оператор кода. Ключевое слово
goto используется для перехода к метке.
Подсказка
Существуют ограничения на то, когда вы можете перейти к метке, например, невозможность перехода к оператору case из-за
пределов охватывающего его оператора switch.

TODO 7. Использование массивов, срезов и карт
 Работа с массивами
 Массивы Go имеют фиксированную длину и содержат элементы одног типа, доступ к которым осуществляется по индексу.
Использование литерального синтаксиса массива
Массивы могут быть определены и заполнены в одном операторе с использованием литерального синтаксиса.
Подсказка
Количество элементов, указанных с литеральным синтаксисом,
может быть меньше емкости массива. Любой позиции в массиве, длякоторой не указано значение, будет присвоено нулевое
значение для типа массива.
СОЗДАНИЕ МНОГОМЕРНЫХ МАССИВОВ
Массивы Go являются одномерными, но их можно комбинировать
для создания многомерных массивов, например:
...
var coords [3][3]int
...
Этот оператор создает массив, емкость которого равна 3 и
базовый тип которого является массивом int, также с емкостью 3,
создавая массив значений int 3×3. Отдельные значения указываются
с использованием двух позиций индекса, например:
...
coords[1][2] = 10
...
Синтаксис немного неудобен, особенно для массивов с большим
количеством измерений, но он функционален и соответствует
подходу Go к массивам.
TODO Понимание типов массивов
 Тип массива — это комбинация его размера и базового типа.
ПОЗВОЛЯЕМ КОМПИЛЯТОРУ ОПРЕДЕЛЯТЬ ДЛИНУ
МАССИВА
При использовании литерального синтаксиса компилятор может
вывести длину массива из списка элементов, например:
...
names := [...]string { "Kayak", "Lifejacket", "Paddle" }
...
Явная длина заменяется тремя точками (...), что указывает
компилятору определять длину массива из литеральных значений.
Тип переменной names по-прежнему [3]string, и единственное
отличие состоит в том, что вы можете добавлять или удалять
литеральные значения, не обновляя при этом явно указанную длину.Я не использую эту функцию для примеров в этой книге,
потому что хочу сделать используемые типы максимально понятными.
 Понимание значений массива
Как я объяснял в главе 4, Go по умолчанию работает со значениями, а не со ссылками. Это поведение распространяется на
массивы, что означает, что присваивание массива новой переменной копирует массив и копирует содержащиеся в нем значения.
 Сравнение массивов
Операторы сравнения == и != можно применять к массивам
Массивы равны, если они одного типа и содержат одинаковые элементы в одном и том же порядке.
 Перечисление массива
Массивы перечисляются с использованием ключевых слов for и range

TODO Работа со срезами
 Лучше всего рассматривать срезы как массив переменной длины, потому что они полезны, когда вы не знаете, сколько
 значений вам нужно сохранить, или когда число меняется со временем. Один из способов определить срез — использовать
 встроенную функцию make.
Добавление элементов в срез
Одним из ключевых преимуществ срезов является то, что их можно расширять для размещения дополнительных элементов.
Выделение дополнительной емкости срезов
Создание и копирование массивов может быть неэффективным. Если вы предполагаете, что вам нужно будет добавлять элементы
в срез, выможете указать дополнительную емкость при использовании функции make.
Подсказка
Вы также можете использовать функции len и cap для стандартных
массивов фиксированной длины. Обе функции будут возвращать
длину массива, так что для массива типа [3]string, например, обе функции вернут 3. См. пример в разделе «Использование
функции копирования»..
Базовый массив не заменяется, когда функция append вызывается для среза с достаточной емкостью для размещения новых
элементов.
Осторожно!!!
Если вы определяете переменную среза, но не инициализируете ее, то результатом будет срез с нулевой длиной и нулевой
емкостью, и это вызовет ошибку при добавлении к нему элемента.
 Добавление одного среза к другому
Функцию append можно использовать для добавления одного среза к другому.
 Создание срезов из существующих массивов
Срезы можно создавать с использованием существующих массивов, что
основано на поведении, описанном в предыдущих примерах, и подчеркивает природу срезов как представлений массивов.
TODO Диапазоны выражены в квадратных скобках, где низкие и высокие значения разделены двоеточием. Первый индекс в срезе
 устанавливается как наименьшее значение, а длина является результатом наибольшего значения минус наименьшее значение.
 Это означает, что диапазон [1:3] создает диапазон, нулевой индекс которого отображается в индекс 1 массива,
 а длина равна 2. Как показывает этот пример, срезы не обязательно выравнивать с началом резервного массива.
 func main() {
 products := [4]string { "Kayak", "Lifejacket", "Paddle", "Hat"}
 someNames := products[1:3]
 allNames := products[:]
 fmt.Println("someNames:", someNames)
 fmt.Println("allNames", allNames)
 fmt.Println(someNames[0]) // Здесь будет "Lifejacket" т.к. это уже нулевое значение индекса в срезе "Lifejacket"  !!!!
}
 Добавление элементов при использовании существующих массивов для срезов.
Связь между срезом и существующим массивом может создавать разные результаты при добавлении элементов.
Как показано в предыдущем примере, можно сместить срез так, чтобы его первая позиция индекса не находилась в начале
массива и чтобы его конечный индекс не указывал на последний элемент массива.
В листинге 7-19 индекс 0 для среза someNames отображается в индекс 1 массива. До сих пор емкость срезов согласовывалась
с длиной базового массива, но это уже не так, поскольку эффект смещения заключается в уменьшении объема массива,
который может использоваться срезом. В листинге 7-20 добавлены операторы, записывающие длину и емкость двух срезов.
TODO Делаем срезы предсказуемыми
То, как срезы могут совместно использовать массив, вызывает путаницу. Некоторые разработчики ожидают, что срезы будут
независимыми, и получают неожиданные результаты, когда значение хранится в массиве, используемом несколькими срезами.
Другие разработчики пишут код, который ожидает общие массивы, и получают неожиданные результаты, когда изменение размера
разделяет срезы.
 Срезы могут показаться непредсказуемыми, но только если обращаться с ними непоследовательно. Мой совет — разделить
срезы на две категории, решить, к какой из них относится срез при его создании, и не менять эту категорию.
Первая категория представляет собой представление фиксированной длины в массиве фиксированной длины. Это более полезно,
чем кажется, потому что срезы могут быть сопоставлены с определенной областью массива, которую можно выбрать программно.
В этой категории вы можете изменять элементы в срезе, но не добавлять новые элементы, что означает, что все срезы,
сопоставленные с этим массивом, будут использовать измененные элементы.
Вторая категория представляет собой набор данных переменной длины. Я удостоверяюсь, что каждый срез в этой категории
имеет свой собственный резервный массив, который не используется никаким другим срезом. Этот подход позволяет мне
свободно добавлять новые элементы в срез, не беспокоясь о влиянии на другие срезы.
 Если вы увязли в срезах и не получили ожидаемых результатов, спросите себя, к какой категории относится каждый из ваших
срезов и не обрабатываете ли вы срезнепоследовательно или создаете срезы из разных категорий из одного и того же
исходного массива.
 Если вы используете срез в качестве фиксированного представления массива, вы можете ожидать, что несколько срезов дадут
вам согласованное представление этого массива, и любые новые значения, которые вы назначите, будут отражены всеми
срезами, которые отображаются в измененный элемент.
 TODO Указание емкости при создании среза из массива
Диапазоны могут включать максимальную емкость, которая обеспечивает некоторую степень контроля над тем,
когда массивыбудут дублироваться.
someNames := products[1:3:3]
Максимальное значение не определяет максимальную емкость напрямую. Вместо этого максимальная емкость определяется путем
вычитания нижнего значения из максимального значения. В примере максимальное значение равно 3, а минимальное значение
равно 1, что означает, что емкость будет ограничена до 2. В результате операция append приводит к изменению размера
среза и выделению собственного массива, вместо расширения в существующем массиве.
 Создание срезов из других срезов
Срезы также можно создавать из других срезов, хотя взаимосвязь между срезами не сохраняется при изменении их размера.
 Срезы ведут себя так же, как и в других примерах в этой главе, и их размер будет изменен, если элементы будут
добавлены, когда нет доступной емкости, и в этот момент они больше не будут использовать общий массив.
Использование функции копирования
Функция copy используется для копирования элементов между срезами. Эту функцию можно использовать для обеспечения того,
чтобы срезы имели отдельные массивы, и для создания срезов, объединяющих элементы из разных источников.
 Использование функции копирования для обеспечения разделения массива срезов
TODO copy(someNames, allNames)  copy - функция, someNames - Получатель, allNames - Источник.
Функцию copy можно использовать для дублирования существующего среза, выбирая некоторые или все элементы, но гарантируя,
что новый срез поддерживается собственным массивом.(str.228).
Функция copy принимает два аргумента: срез назначения и срез источника. Эффект оператора copy заключается в том, что
элементы копируются из среза до тех пор, пока не будет исчерпана длина среза получателя.
 Понимание ловушки неинициализированных срезов
Как я объяснял в предыдущем разделе, функция copy не изменяет размер целевого среза. Распространенной ошибкой является
попытка скопировать элементы в срез, который не был инициализирован.
Никакие элементы не были скопированы в целевой срез. Это происходит потому, что неинициализированные срезы имеют нулевую
длину и нулевую емкость. Функция copy останавливает копирование, когда достигается длина конечной длины, и, поскольку
длина равнанулю, копирование не происходит. Об ошибках не сообщается, потому что функция copy работала так, как
предполагалось, но это редко является ожидаемым эффектом, и это вероятная причина, если вы неожиданно столкнулись с пустым срезом.
 Указание диапазонов при копировании срезов
Детальный контроль над копируемыми элементами может быть достигнут с помощью диапазонов.
 Копирование срезов разного размера
Поведение, которое приводит к проблеме, описанной в разделе
«Понимание ловушки неинициализированных срезов», позволяеткопировать срезы разных размеров, если вы помните об их
инициализации. Если целевой срез больше исходного, то копирование будет продолжаться до тех пор, пока не будет
скопирован последний элемент в источнике.
Если целевой срез меньше исходного, то копирование продолжается до тех пор, пока все элементы в целевом срезе не будут
заменены.
TODO Удаление элементов среза
Встроенной функции для удаления элементов среза нет, но эту операцию можно выполнить с помощью диапазонов и функции
добавления. Чтобы удалить значение, метод append используется для объединения двух диапазонов, содержащих все элементы
среза, кроме того, который больше не требуется.
TODO deleted := append(products[:2], products[3:]...)
TODO Перечисление срезов
Срезы нумеруются так же, как и массивы, с ключевыми словами for и range.
TODO Сортировка срезов (str.235)
Встроенной поддержки сортировки срезов нет, но стандартная библиотека включает пакет sort, определяющий функции для
сортировки различных типов срезов.
TODO Сравнение срезов
Go ограничивает использование оператора сравнения, поэтому срезы можно сравнивать только с нулевым значением.
Сравнение двух срезов приводит к ошибке.
Однако есть один способ сравнения срезов. Стандартная библиотека включает пакет с именем reflect, который включает в
себя удобную функцию DeepEqual. Пакет reflect содержит расширенные функции (именно поэтому для описания предоставляемых
им функций требуется три главы). Функцию DeepEqual можно использовать для сравнения более широкого диапазона типов
данных, чем оператор равенства, включая срезы.
TODO Получение массива, лежащего в основе среза
Если у вас есть срез, но вам нужен массив (обычно потому, что функция требует его в качестве аргумента), вы можете
выполнить явное преобразование среза.

TODO Работа с картами
 Карты — это встроенная структура данных, которая связывает значения данных с ключами. В отличие от массивов, где значе-
 ния связаны с последовательными целочисленными ячейками, карты могут использовать другие типы данных в качестве ключей.
Карты создаются с помощью встроенной функции make, как и срезы. Тип карты указывается с помощью ключевого слова map, за
которым следует тип ключа в квадратных скобках, за которым следует тип значения. Последний аргумент функции make указы-
вает начальную емкость карты. Карты, как и срезы, изменяются автоматически, и аргумент размера может быть опущен.
TODO Использование литерального синтаксиса карты
Срезы также могут быть определены с использованием литерального синтаксиса. Литеральный синтаксис указывает начальное
содержимое карты между фигурными скобками. Каждая запись карты указывается с помощью ключа, двоеточия, значения и запя-
той.
Go очень требователен к синтаксису и выдаст ошибку, если за значением карты не следует ни запятая, ни закрывающая фигур-
ная скобка. Я предпочитаю использовать завершающую запятую, которая позволяет поставить закрывающую фигурную скобку на
следующую строку в файле кода. Ключи, используемые в литеральном синтаксисе, должны быть уникальными, и компилятор
сообщит об ошибке, если одно и то же имя используется для двух литеральных записей.
TODO Проверка элементов в карте
Как отмечалось ранее, карты возвращают нулевое значение для типа значения, когда выполняются чтения, для которых нет
ключа. Это может затруднить различение сохраненного значения, которое оказывается нулевым значением,
и несуществующего ключа.
TODO Удаление объектов с карты (str.243)
Элементы удаляются с карты с помощью встроенной функции удаления.








*/
