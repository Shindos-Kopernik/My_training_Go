package main // Декларация пакета

import "fmt" // Оператор импорта

func main() {
	fmt.Println("Hello, Go") // Функция
}

/* package - ключевое слово; main - имя пакета

import - ключевое слово; "fmt" - имя пакета

func - ключевое слово; main - имя; () - параметры { Блок
	fmt.Println("Hello, Go")                      кода
}

fmt.Println("Hello, Go") Здесь fmt - ссылка на паке; . - Точка; Println - Название функци; ("Hello, Go") - арументы функции

*/

/* TODO Отладка кода Go
   установить пакет Delve go install github.com/go-delve/delve/cmd/dlv@latest
   dlv version
TODO Подготовка к отладке
TODO Использование отладчика стр.74
dlv debug main.go
Первым шагом является
создание точки останова, что делается путем указания местоположения
в коде
TODO break bp1 main.main:3
Команда break создает точку останова.
br1 - Имя
main - Пакет
. - Точка
main - Функция
: - Двоеточие
3 - Строка
Далее я собираюсь создать условие для точки останова, чтобы
выполнение было остановлено только тогда, когда указанное
выражение оценивается как true
condition bp1 i == 2
continue
Запустите команду, показанную в листинге 3-16, чтобы отобразить
текущее значение переменной с именем i.
print i

TODO Линтинг Go-кода

Я предпочитаю
использовать revive пакет линтера, который является прямой заменой
golint, но с поддержкой контроля применяемых правил.

go install github.com/mgechev/revive@latest

Формат TOML предназначен специально для файлов конфигурации
и описан на странице https://toml.io/en. Полный набор
параметров настройки восстановления описан на странице
https://github.com/mgechev/revive#configuration.

revive -config revive.toml // Вывода не будет т.к. правило отключено в revive.tolm

TODO Исправление распространенных проблем в коде Go

Команда go vet идентифицирует операторы, которые могут быть ошибочными.

TODO Форматирование кода Go str.89

go fmt main.go

TODO Использование стандартной библиотеки Go

Синтаксис короткого объявления переменных можно использовать только внутри функций,

Однако переопределение переменной разрешено, если используется короткий синтаксис, если
хотя бы одна из других определяемых переменных еще не существует и тип переменной не изменяется.

TODO Указатели

Тип указателя основан на типе переменной, из которой он создан, с
префиксом звездочки (символ *). Тип переменной с именем second —
*int, потому что она была создана путем применения оператора
адреса к переменной first, значение которой равно int. Когда вы
видите тип *int, вы знаете, что это переменная, значением которой
является адрес памяти, в котором хранится переменная типа int.
Тип указателя фиксирован, потому что все типы Go фиксированы, а
это означает, что когда вы создаете указатель, например, на int, вы
меняете значение, на которое он указывает, но вы не можете
использовать его для указания на адрес памяти, используемый для
хранения другого типа, например, float64. Это ограничение важно,
поскольку в Go указатели — это не просто адреса памяти, а, скорее,
адреса памяти, которые могут хранить определенный тип значения.

TODO 5. Операции и преобразования str/128
 +, -, *, /, % - Эти операторы используются для выполнения арифметических операций с
 числовыми значениями, как описано в разделе «Знакомство с арифметическими
 операторами». Оператор + также можно использовать для объединения строк, как
 описано в разделе «Объединение строк».
TODO
 ==, !=, <, <=, >, >= - Эти операторы сравнивают два значения, как описано в разделе
 «Общие сведения об операторах сравнения»
 == Этот оператор возвращает true, если операнды равны. И используется для сравнения ячеек памяти
 != Этот оператор возвращает true, если операнды не равны.
 < Этот оператор возвращает значение true, если первый операнд меньше второго операнда.
 > Этот оператор возвращает значение true, если первый операнд больше второго операнда.
 <= Этот оператор возвращает значение true, если первый операнд меньше или nравен второму операнду.
 >= Этот оператор возвращает значение true, если первый операнд больше или равен
 второму операнду.
Значения, используемые с операторами сравнения, должны быть
одного типа или должны быть нетипизированными константами,
которые могут быть представлены как целевой тип,
TODO
 ||, &&, ! - Это логические операторы, которые применяются к bool значениям и
 возвращают bool значение, как описано в разделе «Понимание логических
 операторов»
 || Этот оператор возвращает true (истину), если любой из операндов true. Если
 первый операнд true, то второй операнд не будет оцениваться. (ИЛИ)
 && Этот оператор возвращает true, если оба операнда true. Если первый операнд
 false, то второй операнд не будет оцениваться. (И)
 ! Этот оператор используется с одним операндом. Он возвращает true, если
 операнд false, и false, если операнд true.
TODO
 =, := - Это операторы присваивания. Стандартный оператор присваивания (=)
 используется для установки начального значения при определении константы
 или переменной или для изменения значения, присвоенного ранее определенной
 переменной. Сокращенный оператор (:=) используется для определения
 переменной и присвоения значения, как описано в главе 4.
TODO
 -=, +=, ++, -- - Эти операторы увеличивают и уменьшают числовые значения, как описано в
 разделе «Использование операторов увеличения и уменьшения».
 Операторы ++ и -- увеличивают или уменьшают значение на единицу.
 += и -= увеличивают или уменьшают значение на указанную величину.
TODO
 &, |, ^, &^, <<, >> - Это побитовые операторы, которые можно применять к целочисленным
 значениям. Эти операторы не часто требуются в основной разработке, но вы
 можете увидеть пример в главе 31, где оператор | используется для настройки
 функций ведения журнала Go.

TODO Понимание операторов Go
 + Этот оператор возвращает сумму двух операндов.
 - Этот оператор возвращает разницу между двумя операндами.
 * Этот оператор возвращает произведение двух операндов.
 / Этот оператор возвращает частное двух операторов.
 % Этот оператор возвращает остаток от деления, который аналогичен оператору по
 модулю, предоставляемому другими языками программирования, но может
 возвращать отрицательные значения, как описано в разделе «Использование
 оператора остатка».

TODO Сравнение указателей
 Оператор равенства Go (==) используется для сравнения ячеек памяти.

TODO Преобразование, анализ и форматирование значений.
 Выполнение явных преобразований типов:
 Синтаксис для явных преобразований — T(x), где T — это целевой
 тип, а x — это значение или выражение для преобразования.
 Понимание ограничений явных преобразований.
Явные преобразования можно использовать только в том случае, если
значение может быть представлено в целевом типе. Это означает, что
вы можете выполнять преобразование между числовыми типами и
между строками и рунами, но другие комбинации, такие как
преобразование значений int в значения bool, не поддерживаются.
Следует соблюдать осторожность при выборе значений для
преобразования, поскольку явные преобразования могут привести к
потере точности числовых значений или вызвать переполнение
TODO Преобразование значений с плавающей запятой в целые числа.
Как показано в предыдущем примере, явные преобразования могут
привести к неожиданным результатам, особенно при преобразовании
значений с плавающей запятой в целые числа. Самый безопасный
подход — преобразовать в другом направлении, представляя целые
числа и значения с плавающей запятой, но если это невозможно, то
math пакет предоставляет набор полезных функций, которые можно
использовать для выполнения преобразований контролируемым образом.
TODO Функции в пакете math для преобразования числовых типов:
 Ceil(value) - Эта функция возвращает наименьшее целое число, большее
 указанного значения с плавающей запятой. Например, наименьшее
 целое число, большее 27.1, равно 28.
 Floor(value) - Эта функция возвращает наибольшее целое число, которое меньше
 указанного значения с плавающей запятой. Например, наибольшее
 целое число, меньшее 27.1, равно 28. В книге опечатка 27!!!
 Round(value) - Эта функция округляет указанное значение с плавающей запятой до
 ближайшего целого числа.
 RoundToEven(value - Эта функция округляет указанное значение с плавающей запятой до
 ближайшего четного целого числа.
Функции, описанные в выше, возвращают значения float64,
которые затем могут быть явно преобразованы в тип int,
TODO Парсинг из строк (str.146)
 Функции для преобразования строк в другие типы данных (пакет strconv)
 ParseBool(str) - Эта функция преобразует строку в логическое значение. Распознаваемые
 строковые значения: "true", "false", "TRUE", "FALSE", "True", "False",
 "T", "F", "0" и "1".
Если результат ошибки равен нулю, то строка успешно проанализирована. Если результат ошибки не nil, то
синтаксический анализ завершился неудачно.
TODO ParseFloat(str,size) - Эта функция анализирует строку в значение с плавающей запятой
 указанного размера, как описано в разделе «Анализ чисел с плавающей
 запятой».
 ParseInt(str, base, size) - Эта функция анализирует строку в int64 с указанным основанием и
 размером. Допустимые базовые значения: 2 для двоичного, 8 для
 восьмеричного, 16 для шестнадцатеричного и 10, как описано в разделе
 «Синтаксический анализ целых чисел».
 ParseUint(str, base, size) - Эта функция преобразует строку в целое число без знака с указанным
 основанием и размером.
 Atoi(str) - Эта функция преобразует строку в целое число с основанием 10 и
 эквивалентна вызову функции ParseInt(str, 10, 0), как описано в
 разделе «Использование удобной целочисленной функции».
 Функция Atoi принимает только значение для анализа и не
 поддерживает анализ недесятичных значений. Тип результата — int
 вместо int64, создаваемого функцией ParseInt.
TODO Разбор целых чисел.
Функции ParseInt и ParseUint требуют основания числа,
представленного строкой, и размера типа данных, который будет
использоваться для представления проанализированного значения.

TODO Разбор двоичных, восьмеричных и шестнадцатеричных целых чисел.(str.153).
 Аргумент base, полученный функциями Parse<Type>, позволяет анализировать недесятичные числовые строки,
 0b Этот префикс обозначает двоичное значение, например 0b1100100.
 0o Этот префикс обозначает восьмеричное значение, например 0o144.
 0x Этот префикс обозначает шестнадцатеричное значение, например 0x64.
 Использование удобной целочисленной функции.
 Разбор чисел с плавающей запятой.
Первым аргументом функции ParseFloat является анализируемое
значение. Второй аргумент определяет размер результата. Результатом
функции ParseFloat является значение float64, но если указано 32,
то результат можно явно преобразовать в значение float32.
Функция ParseFloat может анализировать значения, выраженные
с помощью экспоненты,
TODO Форматирование значений как строк.
 FormatBool(val) Эта функция возвращает строку true или false в зависимости от значения указанного bool значения.
 FormatInt(val, base) Эта функция возвращает строковое представление указанного значения int64,
 выраженное в указанной системе счисления.
 FormatUint(val, base) Эта функция возвращает строковое представление указанного значения uint64,
 выраженное в указанной базе.
 FormatFloat(val, format, precision, size) Эта функция возвращает строковое представление указанного значения float64,
 выраженное с использованием указанного формата, точности и размера.
 Itoa(val) Эта функция возвращает строковое представление указанного значения int, выраженное с использованием базы 10.

 TODO Форматирование значений с плавающей запятойю
Для выражения значений с плавающей запятой в виде строк требуются
дополнительные параметры конфигурации, поскольку доступны
разные форматы.
Fstring := strconv.FormatFloat(val, 'f', 2, 64)
Estring := strconv.FormatFloat(val, 'e', -1, 64)
Первым аргументом функции FormatFloat является
обрабатываемое значение. Второй аргумент — это byte значение,
указывающее формат строки. Байт обычно выражается как
литеральное значение руны, и в таблице ниже описаны наиболее часто
используемые форматы руны. (Как отмечалось в главе 4, тип byte
является псевдонимом для uint8 и часто для удобства выражается с
помощью руны.)
f - Значение с плавающей запятой будет выражено в форме ±ddd.ddd без
экспоненты, например 49.95.
e, E - Значение с плавающей запятой будет выражено в форме ±ddd.ddde±dd, например,
4.995e+01 или 4.995E+01. Регистр буквы, обозначающей показатель степени,
определяется регистром руны, используемой в качестве аргумента
форматирования.
Функция Описание
g, G - Значение с плавающей запятой будет выражено в формате e/E для больших
показателей степени или в формате f для меньших значений.

Третий аргумент функции FormatFloat указывает количество
цифр, которые будут следовать за десятичной точкой. Специальное
значение -1 можно использовать для выбора наименьшего количества
цифр, которое создаст строку, которую можно будет разобрать обратно
в то же значение с плавающей запятой без потери точности.
Последний аргумент определяет, округляется ли значение с
плавающей запятой, чтобы его можно было выразить как значение
float32 или float64, используя значение 32 или 64.
Эти аргументы означают, что этот оператор форматирует значение,
назначенное переменной с именем val, используя параметр формата f,
с двумя десятичными знаками и округляет так, чтобы значение могло
быть представлено с использованием типа float64:
...
Fstring := strconv.FormatFloat(val, 'f', 2, 64)
...
Эффект заключается в форматировании значения в строку, которую
можно использовать для представления денежной суммы.

TODO 6. Управление потоком выполнения. (str.163)

TODO Использование операторов if.
Ключевое слово else можно использовать для создания дополнительных предложений в операторе if.
Когда ключевое слово else сочетается с ключевым словом if, операторы кода в фигурных скобках выполняются только тогда,
когда выражение true, а выражение в предыдущем предложении false.
Комбинация else/if может быть повторена для создания последовательности предложений, каждое из которых будет выполняться
только тогда, когда все предыдущие выражения были false.
Ключевое слово else можно также использовать для создания резервного предложения, операторы которого будут выполняться
только в том случае, если все выражения if и else/if в операторе дадут ложные результаты.

TODO Понимание области действия оператора if.(str.171)
Каждое предложение в операторе if имеет свою собственную область
видимости, что означает, что доступ к переменным возможен только в
пределах предложения, в котором они определены. Это также означает,
что вы можете использовать одно и то же имя переменной для разных
целей в отдельных предложениях.
TODO Использование оператора инициализации с оператором if.
Go позволяет оператору if использовать оператор инициализации,
который выполняется перед вычислением выражения оператора if.
Оператор инициализации ограничен простым оператором Go, что
означает, в общих чертах, что оператор может определять новую
переменную, присваивать новое значение существующей переменной
или вызывать функцию.
Чаще всего эта функция используется для инициализации
переменной, которая впоследствии используется в выражении.

TODO Использование циклов for.
Ключевое слово for используется для создания циклов, которые
многократно выполняют операторы. Самые простые циклы for будут
повторяться бесконечно, если их не прервет ключевое слово break,
Ключевое слово return также может использоваться для завершения цикла.)
TODO Использование операторов инициализации и завершения.(str.177)
Циклы могут быть определены с помощью дополнительных
операторов, которые выполняются перед первой итерацией цикла
(известные как оператор инициализации) и после каждой итерации
(пост оператор).
Подсказка
Как и в случае с оператором if, круглые скобки могут быть
применены к условию оператора for, но не к операторам
инициализации или пост-операторам.
TODO Продолжение цикла.
Ключевое слово continue можно использовать для прекращения
выполнения операторов цикла for для текущего значения и перехода к
следующей итерации.
TODO Перечисление последовательностей.
Ключевое слово for можно использовать с ключевым словом range для
создания циклов, перебирающих последовательности.
TODO Получение только индексов или значений при перечислении последовательностей.
Go сообщит об ошибке, если переменная определена, но не используется.
Вы можете опустить переменную value в операторе for...range, если вам нужны только значения индекса.
Пустой идентификатор можно использовать, когда вам нужны только значения в последовательности, а не индексы
Пустой идентификатор (символ _) используется для индексной переменной, а обычная переменная используется для значений.

TODO Использование операторов switch.(str.184)
Оператор switch предоставляет альтернативный способ управления
потоком выполнения, основанный на сопоставлении результата
выражения с определенным значением, в отличие от оценки истинного
или ложного результата.

TODO Использование операторов switch
Оператор switch предоставляет альтернативный способ управления потоком выполнения, основанный на сопоставлении
результата выражения с определенным значением, в отличие от оценки истинного или ложного результата то может быть
краткий способ выполнения множественных сравнений,предоставляющий менее многословную альтернативу сложному
оператору if/elseif/else.
Примечание
Оператор switch можно также использовать для различения типов
данных, как описано в главе 11.
За ключевым словом switch следует значение или выражение, которое дает результат, используемый для сравнения. Сравнения
выполняются с серией операторов case, каждый из которых определяет значение.
 Сопоставление нескольких значений
В некоторых языках операторы switch «проваливаются», что означает, что после того, как оператор case установил
совпадение, операторы выполняются до тех пор, пока не будет достигнут оператор break, даже если это означает выполнение
операторов из последующего оператора case. Провал часто используется для того, чтобы позволить нескольким операторам
case выполнять один и тот же код, но он требует тщательного использования ключевого слова break, чтобы предотвратить
неожиданное выполнение выполнения.
 Операторы Go switch не выполняются автоматически, но можно указать несколько значений в списке, разделенном запятыми.
 Прекращение выполнения оператора case
Хотя ключевое слово break не требуется для завершения каждого оператора case, его можно использовать для завершения
выполнения операторов до того, как будет достигнут конец оператора case.
 Принудительный переход к следующему оператору case
Операторы Go switch не проваливаются автоматически, но это поведение можно включить с помощью ключевого слова fallthrough
 Предоставление пункта по умолчанию
Ключевое слово default используется для определения предложения, которое будет выполняться, когда ни один из операторов
case не соответствует значению оператора switch.
 Исключение значения сравнения
Go предлагает другой подход к операторам switch, который опускает значение сравнения и использует выражения в операторах
case. Этоподтверждает идею о том, что операторы switch являются краткой альтернативой операторам if.
 Использование операторов меток
Операторы меток позволяют выполнять переход к другой точке, обеспечивая большую гибкость, чем другие функции управления
потоком. Метки определяются именем, за которым следует двоеточие, а затем обычный оператор кода. Ключевое слово
goto используется для перехода к метке.
Подсказка
Существуют ограничения на то, когда вы можете перейти к метке, например, невозможность перехода к оператору case из-за
пределов охватывающего его оператора switch.

TODO 7. Использование массивов, срезов и карт
 Работа с массивами
 Массивы Go имеют фиксированную длину и содержат элементы одног типа, доступ к которым осуществляется по индексу.
Использование литерального синтаксиса массива
Массивы могут быть определены и заполнены в одном операторе с использованием литерального синтаксиса.
Подсказка
Количество элементов, указанных с литеральным синтаксисом,
может быть меньше емкости массива. Любой позиции в массиве, длякоторой не указано значение, будет присвоено нулевое
значение для типа массива.
СОЗДАНИЕ МНОГОМЕРНЫХ МАССИВОВ
Массивы Go являются одномерными, но их можно комбинировать
для создания многомерных массивов, например:
...
var coords [3][3]int
...
Этот оператор создает массив, емкость которого равна 3 и
базовый тип которого является массивом int, также с емкостью 3,
создавая массив значений int 3×3. Отдельные значения указываются
с использованием двух позиций индекса, например:
...
coords[1][2] = 10
...
Синтаксис немного неудобен, особенно для массивов с большим
количеством измерений, но он функционален и соответствует
подходу Go к массивам.
TODO Понимание типов массивов
 Тип массива — это комбинация его размера и базового типа.
ПОЗВОЛЯЕМ КОМПИЛЯТОРУ ОПРЕДЕЛЯТЬ ДЛИНУ
МАССИВА
При использовании литерального синтаксиса компилятор может
вывести длину массива из списка элементов, например:
...
names := [...]string { "Kayak", "Lifejacket", "Paddle" }
...
Явная длина заменяется тремя точками (...), что указывает
компилятору определять длину массива из литеральных значений.
Тип переменной names по-прежнему [3]string, и единственное
отличие состоит в том, что вы можете добавлять или удалять
литеральные значения, не обновляя при этом явно указанную длину.Я не использую эту функцию для примеров в этой книге,
потому что хочу сделать используемые типы максимально понятными.
 Понимание значений массива
Как я объяснял в главе 4, Go по умолчанию работает со значениями, а не со ссылками. Это поведение распространяется на
массивы, что означает, что присваивание массива новой переменной копирует массив и копирует содержащиеся в нем значения.
 Сравнение массивов
Операторы сравнения == и != можно применять к массивам
Массивы равны, если они одного типа и содержат одинаковые элементы в одном и том же порядке.
 Перечисление массива
Массивы перечисляются с использованием ключевых слов for и range

TODO Работа со срезами
 Лучше всего рассматривать срезы как массив переменной длины, потому что они полезны, когда вы не знаете, сколько
 значений вам нужно сохранить, или когда число меняется со временем. Один из способов определить срез — использовать
 встроенную функцию make.
Добавление элементов в срез
Одним из ключевых преимуществ срезов является то, что их можно расширять для размещения дополнительных элементов.
Выделение дополнительной емкости срезов
Создание и копирование массивов может быть неэффективным. Если вы предполагаете, что вам нужно будет добавлять элементы
в срез, выможете указать дополнительную емкость при использовании функции make.
Подсказка
Вы также можете использовать функции len и cap для стандартных
массивов фиксированной длины. Обе функции будут возвращать
длину массива, так что для массива типа [3]string, например, обе функции вернут 3. См. пример в разделе «Использование
функции копирования»..
Базовый массив не заменяется, когда функция append вызывается для среза с достаточной емкостью для размещения новых
элементов.
Осторожно!!!
Если вы определяете переменную среза, но не инициализируете ее, то результатом будет срез с нулевой длиной и нулевой
емкостью, и это вызовет ошибку при добавлении к нему элемента.




*/
